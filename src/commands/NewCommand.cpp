#include <vix/cli/commands/NewCommand.hpp>
#include <vix/utils/Logger.hpp>

#include <filesystem>
#include <fstream>
#include <string>
#include <stdexcept>
#include <cstdlib>

namespace fs = std::filesystem;

/**
 * @file NewCommand.cpp
 * @brief Implements `vix new <name>` to scaffold a minimal Vix.cpp project.
 *
 * This command creates a tiny, ready-to-build C++ project:
 *   - `src/main.cpp`  : a minimal HTTP server with a single GET "/" route returning JSON
 *   - `CMakeLists.txt`: a simple, portable build script that links against Vix::vix
 *   - `README.md`     : quick instructions to build and run the app
 *
 * Design goals:
 *   - Robust path handling: projects are created at the repository root by default,
 *     or under $VIX_PROJECTS_DIR if set, or under $VIX_REPO_ROOT if provided.
 *   - No clobbering: refuses to create into a non-empty existing directory.
 *   - Works both inside the monorepo (via add_subdirectory) and with an installed Vix
 *     (via find_package(Vix CONFIG REQUIRED)).
 */

namespace
{

    // --- Minimal content: Hello world HTTP ---
    constexpr const char *kMainCpp = R"(#include <vix.hpp>
using namespace Vix;

int main()
{
    App app;

    // GET /
    app.get("/", [](auto &, auto &res)
            { res.json({"message", "Hello world"}); });

    app.run(8080);
}
)";

    // Generate a simple README with build/run instructions (standalone-first).
    static std::string make_readme(const std::string &projectName)
    {
        return "# " + projectName + R"(

A minimal starter project generated by **Vix CLI**.

## Build (standalone)

Vix must be installed system-wide (so `find_package(Vix CONFIG REQUIRED)` can find it).

```bash
mkdir -p build && cd build
cmake -S .. -B . -DCMAKE_BUILD_TYPE=Release
cmake --build . -j
./)" + projectName +
               R"(
Build (inside Vix monorepo)

If this project was generated inside the Vix repository, the CMake uses add_subdirectory(...)
to reference the local Vix sources without rebuilding them when you compile this app:
```bash
mkdir -p build && cd build
cmake -S .. -B . -DCMAKE_BUILD_TYPE=Release
cmake --build . -j
./)" + projectName +
               R"(

# Then open http://localhost:8080/ in your browser
)";
    }

    // CMakeLists.txt template:
    // 1) Try using the local Vix source (absolute path injected).
    // 2) Otherwise require an installed Vix (CONFIG mode).
    // 3) Link against Vix::vix; never rebuild the framework in standalone use.
    static std::string make_cmakelists(const std::string &projectName,
                                       const fs::path &vixSourceDirAbs)
    {
        const std::string vixRoot = vixSourceDirAbs.empty() ? std::string("") : vixSourceDirAbs.string();
        std::string s;
        s.reserve(4096);

        s += "cmake_minimum_required(VERSION 3.20)\n";
        s += "project(" + projectName + " LANGUAGES CXX)\n\n";

        s += "# ---------------------- Language / Standard ----------------------\n";
        s += "set(CMAKE_CXX_STANDARD 20)\n";
        s += "set(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n";

        s += "# ----------------------------- Options ---------------------------\n";
        s += "# Enable with: -DVIX_ENABLE_SANITIZERS=ON\n";
        s += "option(VIX_ENABLE_SANITIZERS \"Enable ASan/UBSan (dev only)\" OFF)\n\n";

        s += "# ---------------------- Use local Vix source ---------------------\n";
        s += "set(VIX_LOCAL_SOURCE_DIR \"" + vixRoot + "\")\n";
        s += "if (EXISTS \"${VIX_LOCAL_SOURCE_DIR}/CMakeLists.txt\")\n";
        s += "  message(STATUS \"Using local Vix source: ${VIX_LOCAL_SOURCE_DIR}\")\n";
        s += "  add_subdirectory(\"${VIX_LOCAL_SOURCE_DIR}\" \"${CMAKE_BINARY_DIR}/_vix_build\" EXCLUDE_FROM_ALL)\n";
        s += "  set(VIX_FROM_LOCAL_SOURCE ON)\n";
        s += "else()\n";
        s += "  set(VIX_FROM_LOCAL_SOURCE OFF)\n";
        s += "endif()\n\n";

        s += "# ---------------------- Installed package path -------------------\n";
        s += "if (NOT VIX_FROM_LOCAL_SOURCE)\n";
        s += "  find_package(Vix CONFIG REQUIRED)  # provides target Vix::vix\n";
        s += "endif()\n\n";

        s += "# -------------------------- Executable ---------------------------\n";
        s += "add_executable(" + projectName + " src/main.cpp)\n";
        s += "target_link_libraries(" + projectName + " PRIVATE Vix::vix)\n";
        s += "set_target_properties(" + projectName + " PROPERTIES\n";
        s += "  RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}\"\n";
        s += ")\n\n";

        s += "# ------------------------ Warnings (nice) ------------------------\n";
        s += "if (MSVC)\n";
        s += "  target_compile_options(" + projectName + " PRIVATE /W4 /permissive-)\n";
        s += "else()\n";
        s += "  target_compile_options(" + projectName + " PRIVATE -Wall -Wextra -Wpedantic)\n";
        s += "endif()\n\n";

        s += "# ---------------------- Optional Sanitizers ----------------------\n";
        s += "if (VIX_ENABLE_SANITIZERS)\n";
        s += "  if (MSVC)\n";
        s += "    message(WARNING \"Sanitizers are not configured for MSVC in this template.\")\n";
        s += "  else()\n";
        s += "    target_compile_options(" + projectName + " PRIVATE -O1 -g -fno-omit-frame-pointer -fsanitize=address,undefined)\n";
        s += "    target_link_options(" + projectName + " PRIVATE -fsanitize=address,undefined)\n";
        s += "  endif()\n";
        s += "endif()\n\n";

        s += "# --------------------------- Notes -------------------------------\n";
        s += "# - In monorepo mode, this app reuses the local Vix tree via add_subdirectory.\n";
        s += "# - In standalone mode, Vix must be installed and discoverable by CMake.\n";

        return s;

        // Write a whole text file (binary mode to avoid newline conversion).
        void write_text_file(const fs::path &p, const std::string &content)
        {
            std::ofstream ofs(p, std::ios::binary | std::ios::trunc);
            if (!ofs)
                throw std::runtime_error("Cannot open file: " + p.string());

            // ✅ correction : pas d’espace entre static_cast et <>, bon ordre des arguments
            ofs.write(content.data(), static_cast<std::streamsize>(content.size()));

            if (!ofs)
                throw std::runtime_error("Failed to write file: " + p.string());
        }

        // Detect repository root (go up from typical build dirs until we find CMakeLists.txt + modules/).
        fs::path detect_repo_root()
        {
            // 1) Highest priority: explicit environment variable
            if (const char *p = std::getenv("VIX_REPO_ROOT"))
            {
                fs::path env = fs::path(p);
                if (fs::exists(env) && fs::is_directory(env))
                    return fs::canonical(env);
            }

            fs::path cwd = fs::current_path();
            fs::path parent = cwd.parent_path();

            // Simple heuristic: parent with CMakeLists.txt + modules/
            if (fs::exists(parent / "CMakeLists.txt") && fs::exists(parent / "modules"))
                return fs::canonical(parent);

            // Walk up to 5 levels to find a plausible repo root
            fs::path cur = cwd;
            for (int i = 0; i < 5 && !cur.empty(); ++i)
            {
                if (fs::exists(cur / "CMakeLists.txt") && fs::exists(cur / "modules"))
                    return fs::canonical(cur);
                cur = cur.parent_path();
            }

            // Fallback: current working directory (no guarantee Vix sources exist here)
            return fs::canonical(cwd);
        }

    } // namespace

    namespace Vix::Commands::NewCommand
    {

        int run(const std::vector<std::string> &args)
        {
            auto &logger = Vix::Logger::getInstance();
            if (args.empty())
            {
                logger.logModule("NewCommand", Vix::Logger::Level::ERROR,
                                 "Usage: vix new <project_name>");
                return 1;
            }

            const std::string name = args[0];

            try
            {
                // 1) Find repo root (enables add_subdirectory fallback)
                fs::path repoRoot = detect_repo_root();

                // 2) Decide where to create the project (default: repo root)
                fs::path baseDir = repoRoot;
                if (const char *p = std::getenv("VIX_PROJECTS_DIR"))
                {
                    fs::path custom = fs::path(p);
                    if (fs::exists(custom) && fs::is_directory(custom))
                    {
                        baseDir = fs::canonical(custom);
                    }
                    else
                    {
                        logger.logModule("NewCommand", Vix::Logger::Level::WARN,
                                         "VIX_PROJECTS_DIR is invalid: {} — falling back to repo root",
                                         p ? p : "(null)");
                    }
                }

                // Avoid "./vix/<name>" relative to the build dir (may collide with the 'vix' executable)
                fs::path projectDir = baseDir / name;
                fs::path srcDir = projectDir / "src";
                fs::path mainCpp = srcDir / "main.cpp";
                fs::path cmakeLists = projectDir / "CMakeLists.txt";
                fs::path readmeFile = projectDir / "README.md";

                // 3) Safety: do not clobber an existing non-empty directory
                if (fs::exists(projectDir) && !fs::is_empty(projectDir))
                {
                    logger.logModule("NewCommand", Vix::Logger::Level::ERROR,
                                     "Directory '{}' already exists and is not empty.", projectDir.string());
                    return 2;
                }

                // 4) Create tree and files
                fs::create_directories(srcDir);
                write_text_file(mainCpp, kMainCpp);
                write_text_file(cmakeLists, make_cmakelists(name, repoRoot));
                write_text_file(readmeFile, make_readme(name));

                logger.logModule("NewCommand", Vix::Logger::Level::INFO,
                                 "✅ Project '{}' created at {}", name, projectDir.string());

                logger.logModule("NewCommand", Vix::Logger::Level::INFO,
                                 "Build & Run:\n"
                                 "  mkdir -p {0}/build && cd {0}/build\n"
                                 "  cmake -S .. -B . -DCMAKE_BUILD_TYPE=Release\n"
                                 "  cmake --build . -j\n"
                                 "  ./{1}",
                                 projectDir.string(), name);

                return 0;
            }
            catch (const std::exception &ex)
            {
                logger.logModule("NewCommand", Vix::Logger::Level::ERROR,
                                 "Failed to create project '{}': {}", name, ex.what());
                return 3;
            }
        }

    } // namespace Vix::Commands::NewCommand