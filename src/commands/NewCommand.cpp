#include <vix/cli/commands/NewCommand.hpp>
#include <vix/utils/Logger.hpp>

#include <filesystem>
#include <fstream>
#include <string>
#include <stdexcept>
#include <cstdlib>
#include <vector>
#include <optional>

#include <random>
#include <system_error>

namespace fs = std::filesystem;

namespace
{

    // --------- Minimal hello-world server (API Vix moderne) ----------
    constexpr const char *kMainCpp = R"(#include <vix.hpp>
using namespace Vix;

int main()
{
    App app;

    // GET /
    app.get("/", [](auto&, auto& res) {
        res.json({"message", "Hello world"});
    });

    app.run(8080);
}
)";

    // README generator
    std::string make_readme(const std::string &projectName)
    {
        return "# " + projectName + R"(

A minimal starter project generated by **Vix CLI**.

## Build (standalone, with installed Vix)

```bash
mkdir -p build && cd build
cmake -S .. -B . -DCMAKE_BUILD_TYPE=Release
cmake --build . -j
./)" + projectName +
               R"(
If Vix is not found as a CMake package, this template tries local static fallbacks
(core/utils/json) under /usr/local. Adjust paths in CMakeLists.txt if needed.

Open http://localhost:8080/

)";
    }

    // ------- CMakeLists template with package-first + fallback (portable) ------
    static std::string make_cmakelists(const std::string &projectName)
    {
        std::string s;
        s.reserve(8192);
        s += "cmake_minimum_required(VERSION 3.20)\n";
        s += "project(" + projectName + " LANGUAGES CXX)\n\n";

        s += "# ===== C++ standard =====\n";
        s += "set(CMAKE_CXX_STANDARD 20)\n";
        s += "set(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n";

        s += "option(VIX_ENABLE_SANITIZERS \"Enable ASan/UBSan (dev only)\" OFF)\n\n";

        s += "# ===== Search prefixes (edit if your install lives elsewhere) =====\n";
        s += "list(APPEND CMAKE_PREFIX_PATH\n";
        s += "  \"/usr/local\"\n";
        s += "  \"/usr/local/lib/cmake/Vix\"\n";
        s += "  \"/usr/local/lib/cmake/VixOrm\"\n";
        s += ")\n\n";

        s += "# ===== Try packages (quiet) =====\n";
        s += "find_package(Vix CONFIG QUIET)\n";
        s += "find_package(VixOrm CONFIG QUIET)\n\n";

        s += "# ===== Fallbacks for Vix module targets if packages are missing =====\n";
        s += "set(_VIX_INC \"/usr/local/include\")\n";
        s += "set(_VIX_LIBDIR \"/usr/local/lib\")\n\n";

        s += "# core\n";
        s += "if (NOT TARGET Vix::core)\n";
        s += "  find_library(VIX_CORE_LIB NAMES vix_core PATHS \"${_VIX_LIBDIR}\" NO_DEFAULT_PATH)\n";
        s += "  if (VIX_CORE_LIB)\n";
        s += "    add_library(Vix::core STATIC IMPORTED GLOBAL)\n";
        s += "    set_target_properties(Vix::core PROPERTIES\n";
        s += "      IMPORTED_LOCATION \"${VIX_CORE_LIB}\"\n";
        s += "      INTERFACE_INCLUDE_DIRECTORIES \"${_VIX_INC}\")\n";
        s += "    message(STATUS \"Using fallback Vix::core at ${VIX_CORE_LIB}\")\n";
        s += "  endif()\n";
        s += "endif()\n\n";

        s += "# utils\n";
        s += "if (NOT TARGET Vix::utils)\n";
        s += "  find_library(VIX_UTILS_LIB NAMES vix_utils PATHS \"${_VIX_LIBDIR}\" NO_DEFAULT_PATH)\n";
        s += "  if (VIX_UTILS_LIB)\n";
        s += "    add_library(Vix::utils STATIC IMPORTED GLOBAL)\n";
        s += "    set_target_properties(Vix::utils PROPERTIES\n";
        s += "      IMPORTED_LOCATION \"${VIX_UTILS_LIB}\"\n";
        s += "      INTERFACE_INCLUDE_DIRECTORIES \"${_VIX_INC}\")\n";
        s += "    message(STATUS \"Using fallback Vix::utils at ${VIX_UTILS_LIB}\")\n";
        s += "  endif()\n";
        s += "endif()\n\n";

        s += "# json (headers only)\n";
        s += "if (NOT TARGET Vix::json AND EXISTS \"${_VIX_INC}/vix/json/json.hpp\")\n";
        s += "  add_library(Vix::json INTERFACE IMPORTED GLOBAL)\n";
        s += "  set_target_properties(Vix::json PROPERTIES\n";
        s += "    INTERFACE_INCLUDE_DIRECTORIES \"${_VIX_INC}\")\n";
        s += "  message(STATUS \"Using fallback Vix::json headers at ${_VIX_INC}\")\n";
        s += "endif()\n\n";

        s += "# ===== Umbrella target Vix::vix (only if missing) =====\n";
        s += "if (NOT TARGET Vix::vix)\n";
        s += "  set(_JSON_TGT \"\")\n";
        s += "  if (TARGET Vix::json)\n";
        s += "    set(_JSON_TGT \"Vix::json\")\n";
        s += "  endif()\n";
        s += "  if (TARGET Vix::core AND TARGET Vix::utils AND NOT _JSON_TGT STREQUAL \"\")\n";
        s += "    add_library(Vix::vix INTERFACE IMPORTED GLOBAL)\n";
        s += "    set_property(TARGET Vix::vix PROPERTY INTERFACE_LINK_LIBRARIES Vix::core;Vix::utils;${_JSON_TGT})\n";
        s += "    set_property(TARGET Vix::vix PROPERTY INTERFACE_INCLUDE_DIRECTORIES \"${_VIX_INC}\")\n";
        s += "    message(WARNING \"Vix::vix not found; created local umbrella (core/utils/json).\")\n";
        s += "  else()\n";
        s += "    message(FATAL_ERROR \"Missing Vix targets: need core+utils+json. Install Vix under /usr/local or adjust paths.\")\n";
        s += "  endif()\n";
        s += "endif()\n\n";

        s += "# ===== Executable =====\n";
        s += "add_executable(" + projectName + " src/main.cpp)\n";
        s += "set_target_properties(" + projectName + " PROPERTIES\n";
        s += "  RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}\"\n";
        s += "  INSTALL_RPATH_USE_LINK_PATH ON)\n";
        s += "target_link_libraries(" + projectName + " PRIVATE Vix::vix)\n\n";

        s += "# System deps for static builds\n";
        s += "find_package(Threads REQUIRED)\n";
        s += "target_link_libraries(" + projectName + " PRIVATE Threads::Threads)\n\n";

        s += "find_package(OpenSSL QUIET)\n";
        s += "if (OpenSSL_FOUND)\n";
        s += "  target_link_libraries(" + projectName + " PRIVATE OpenSSL::SSL OpenSSL::Crypto)\n";
        s += "endif()\n\n";

        s += "if (UNIX AND NOT APPLE)\n";
        s += "  target_link_libraries(" + projectName + " PRIVATE dl)\n";
        s += "endif()\n\n";

        s += "# ===== Warnings =====\n";
        s += "if (MSVC)\n";
        s += "  target_compile_options(" + projectName + " PRIVATE /W4 /permissive-)\n";
        s += "else()\n";
        s += "  target_compile_options(" + projectName + " PRIVATE -Wall -Wextra -Wpedantic)\n";
        s += "endif()\n\n";

        s += "# ===== Sanitizers (optional) =====\n";
        s += "if (VIX_ENABLE_SANITIZERS AND NOT MSVC)\n";
        s += "  target_compile_options(" + projectName + " PRIVATE -O1 -g -fno-omit-frame-pointer -fsanitize=address,undefined)\n";
        s += "  target_link_options(" + projectName + " PRIVATE -fsanitize=address,undefined)\n";
        s += "endif()\n";

        return s;
    }

    // Écrit un fichier texte de manière sûre : fichier temporaire puis renommage.
    // - Crée les répertoires parents si nécessaires.
    // - Utilise un fichier .tmp dans le même dossier pour éviter les problèmes de volume.
    // - Tente un remplacement atomique (selon l’OS / FS).
    inline void write_text_file(const fs::path &p, std::string_view content)
    {
        std::error_code ec;

        // 1) Assure l'existence du parent (si applicable)
        const fs::path parent = p.parent_path();
        if (!parent.empty())
        {
            fs::create_directories(parent, ec);
            if (ec)
            {
                throw std::runtime_error("Cannot create directories for: " + parent.string() +
                                         " — " + ec.message());
            }
        }

        // 2) Fichier temporaire à côté de la cible
        auto make_tmp_name = [&]()
        {
            // suffixe pseudo-aléatoire lisible
            std::mt19937_64 rng{std::random_device{}()};
            auto rnd = rng();
            return p.string() + ".tmp-" + std::to_string(rnd);
        };

        fs::path tmp = make_tmp_name();

        // 3) Écriture (binaire) + flush + close
        {
            std::ofstream ofs(tmp, std::ios::binary | std::ios::trunc);
            if (!ofs)
            {
                // Nettoyage défensif
                fs::remove(tmp, ec);
                throw std::runtime_error("Cannot open temp file for write: " + tmp.string());
            }

            ofs.write(content.data(), static_cast<std::streamsize>(content.size()));
            if (!ofs)
            {
                ofs.close();
                fs::remove(tmp, ec);
                throw std::runtime_error("Failed to write file: " + tmp.string());
            }

            ofs.flush();
            if (!ofs)
            {
                ofs.close();
                fs::remove(tmp, ec);
                throw std::runtime_error("Failed to flush file: " + tmp.string());
            }
            // close à la sortie du bloc
        }

        // 4) Rename → p (tentative atomique). Sous Windows, si p existe, rename peut échouer.
        fs::rename(tmp, p, ec);
        if (ec)
        {
            // Essaye de supprimer la cible existante puis renommer à nouveau
            fs::remove(p, ec); // on ignore l'erreur ici (si n'existe pas)
            ec.clear();
            fs::rename(tmp, p, ec);
            if (ec)
            {
                // En dernier recours, on supprime le tmp pour éviter les orphelins
                std::error_code ec2;
                fs::remove(tmp, ec2);
                throw std::runtime_error("Failed to move temp file to destination: " +
                                         tmp.string() + " → " + p.string() + " — " + ec.message());
            }
        }
    }

    // Renvoie true si le répertoire est vide ou n'existe pas; false sinon.
    // N'émet **pas** d'exception : utile dans les checks préalables.
    inline bool is_dir_empty(const fs::path &p) noexcept
    {
        std::error_code ec;

        if (!fs::exists(p, ec))
        {
            return true; // inexistant ≈ "considéré vide" pour nos besoins
        }
        if (ec)
        {
            return false; // prudence
        }
        if (!fs::is_directory(p, ec))
        {
            return false;
        }
        if (ec)
        {
            return false;
        }

        fs::directory_iterator it(p, ec);
        if (ec)
        {
            return false;
        }
        return (it == fs::directory_iterator{});
    }

    // Récupère la valeur de --dir / -d si présente.
    // Supporte: "-d PATH", "--dir PATH", et "--dir=PATH".
    inline std::optional<std::string> pick_dir_opt(const std::vector<std::string> &args)
    {
        for (size_t i = 0; i < args.size(); ++i)
        {
            const std::string &a = args[i];

            if (a == "-d" || a == "--dir")
            {
                if (i + 1 < args.size())
                {
                    return args[i + 1];
                }
                else
                {
                    // option sans valeur → ignorée (on laisse le caller gérer le défaut)
                    return std::nullopt;
                }
            }

            // format --dir=/chemin
            constexpr const char prefix[] = "--dir=";
            if (a.rfind(prefix, 0) == 0 && a.size() > sizeof(prefix) - 1)
            {
                return a.substr(sizeof(prefix) - 1);
            }
        }
        return std::nullopt;
    }

} // namespace

namespace Vix::Commands::NewCommand
{

    int run(const std::vector<std::string> &args)
    {
        auto &logger = ::Vix::Logger::getInstance();

        if (args.empty())
        {
            logger.logModule("NewCommand", ::Vix::Logger::Level::ERROR,
                             "Usage: vix new <name|path> [-d|--dir <base_dir>]");
            return 1;
        }

        // 1) parse nameOrPath and optional base dir
        const std::string nameOrPath = args[0];
        std::optional<std::string> baseOpt = pick_dir_opt(args);

        try
        {
            fs::path dest;

            // If -d/--dir provided → join base + nameOrPath (if nameOrPath is relative)
            if (baseOpt.has_value())
            {
                fs::path base = fs::path(*baseOpt);
                if (!fs::exists(base) || !fs::is_directory(base))
                {
                    logger.logModule("NewCommand", ::Vix::Logger::Level::ERROR,
                                     "Base directory '{}' is invalid.", base.string());
                    return 2;
                }
                fs::path np = fs::path(nameOrPath);
                dest = np.is_absolute() ? np : (fs::canonical(base) / np);
            }
            else
            {
                // No base option: if user passed absolute or relative path, respect it.
                // If it's just a bare name, create under current working directory.
                fs::path np = fs::path(nameOrPath);
                dest = np.is_absolute() ? np : (fs::current_path() / np);
            }

            fs::path projectDir = dest;
            fs::path srcDir = projectDir / "src";
            fs::path mainCpp = srcDir / "main.cpp";
            fs::path cmakeLists = projectDir / "CMakeLists.txt";
            fs::path readmeFile = projectDir / "README.md";

            // 2) safety: don't clobber non-empty dir
            if (fs::exists(projectDir) && !is_dir_empty(projectDir))
            {
                logger.logModule("NewCommand", ::Vix::Logger::Level::ERROR,
                                 "Directory '{}' already exists and is not empty.", projectDir.string());
                return 3;
            }

            // 3) create tree + files
            fs::create_directories(srcDir);
            write_text_file(mainCpp, kMainCpp);
            write_text_file(cmakeLists, make_cmakelists(projectDir.filename().string()));
            write_text_file(readmeFile, make_readme(projectDir.filename().string()));

            logger.logModule("NewCommand", ::Vix::Logger::Level::INFO,
                             "✅ Project created at {}", projectDir.string());

            logger.logModule("NewCommand", ::Vix::Logger::Level::INFO,
                             "Build & Run:\n"
                             "  mkdir -p \"{0}/build\" && cd \"{0}/build\"\n"
                             "  cmake -S .. -B . -DCMAKE_BUILD_TYPE=Release\n"
                             "  cmake --build . -j\n"
                             "  ./\"{1}\"",
                             projectDir.string(), projectDir.filename().string());

            return 0;
        }
        catch (const std::exception &ex)
        {
            logger.logModule("NewCommand", ::Vix::Logger::Level::ERROR,
                             "Failed to create project: {}", ex.what());
            return 4;
        }
    }

} // namespace Vix::Commands::NewCommand